================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-07-29T14:31:53.542Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
src/
  components/
    Cell/
      components/
        SelectedCellOverlay.tsx
      Cell.tsx
    RenderDateRange.tsx
    SingleDay.tsx
    TaskList.tsx
    Toolbar.tsx
  contexts/
    SelectCellsContext.tsx
    ToolbarContext.tsx
  data/
    cellGroupTotalTime.tsx
  test/
    taskData.json
    timesheet.json
  utils/
    timesToCells.tsx
    updateData.ts
    utils.ts
  App.css
  App.tsx
  index.css
  main.tsx
  vite-env.d.ts
.eslintrc.cjs
index.html
package.json
plan.md
README.md
tsconfig.json
tsconfig.node.json
vite.config.ts

================================================================
Repository Files
================================================================

================
File: .eslintrc.cjs
================
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    'eslint:recommended',
    'plugin:@typescript-eslint/recommended',
    'plugin:react-hooks/recommended',
  ],
  ignorePatterns: ['dist', '.eslintrc.cjs'],
  parser: '@typescript-eslint/parser',
  plugins: ['react-refresh'],
  rules: {
    'react-refresh/only-export-components': [
      'warn',
      { allowConstantExport: true },
    ],
  },
}

================
File: index.html
================
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Vite + React + TS</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "blocks-time-tracker",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "tsc && vite build",
    "lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0",
    "preview": "vite preview"
  },
  "dependencies": {
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "styled-components": "^6.1.11"
  },
  "devDependencies": {
    "@types/react": "^18.2.66",
    "@types/react-dom": "^18.2.22",
    "@typescript-eslint/eslint-plugin": "^7.2.0",
    "@typescript-eslint/parser": "^7.2.0",
    "@vitejs/plugin-react": "^4.2.1",
    "eslint": "^8.57.0",
    "eslint-plugin-react-hooks": "^4.6.0",
    "eslint-plugin-react-refresh": "^0.4.6",
    "typescript": "^5.2.2",
    "vite": "^5.2.0"
  }
}

================
File: README.md
================
# Blocks Time Tracker

A work in progress time tracking application.

================
File: src\App.css
================
.App {
  text-align: center;
}

html {
  height: 100%;
}

body {
  height: 100%;
  margin: 0;
  padding: 0;
}

================
File: src\App.tsx
================
import "./App.css";
import { SelectedCellsProvider } from "./contexts/SelectCellsContext";
import { Toolbar } from "./components/Toolbar";
import { ToolbarProvider } from "./contexts/ToolbarContext";
import { RenderDateRange } from "./components/RenderDateRange";
import styled from "styled-components";

//Main app
const App = () => {
  return (
    <Main draggable="false">
      <ToolbarProvider>
        <SelectedCellsProvider>
          <RenderDateRange />
        </SelectedCellsProvider>
        <Toolbar />
      </ToolbarProvider>
    </Main>
  );
};

const Main = styled.div`
  position: relative;
  height: 100vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  justify-content: space-between;
`

export default App;

================
File: src\components\Cell\Cell.tsx
================
import { useContext } from "react";
import { ToolbarContext } from "../../contexts/ToolbarContext";
import { SelectedCellOverlay } from "./components/SelectedCellOverlay";
import styled from "styled-components";

export const Cell = ({ cellIndex, cell, dayToRender, selected, groupPosition = null }) => {
  const { pickedColor, eraseTool, tasks } = useContext(ToolbarContext);
  return (
    <CellContainer
      id={`cell-${cellIndex}`}
      draggable="false"
      key={cellIndex}
      data-day={dayToRender}
      data-time={cell.startTime}
      data-cell-index={cellIndex}
      groupPosition={groupPosition}
    >
      {selected && !eraseTool && (
        <SelectedCellOverlay pickedColor={pickedColor} groupPosition={groupPosition}/>
      )}
      {cell.tasks.length > 0 && !(selected && eraseTool) && (
        <InnerCellContainer groupPosition={groupPosition}>
          {cell.tasks.map((task) => {
            const cellProps = cell.getCellProps(task, tasks[task.taskID].color)
            return (
              <InnerCell
                {...cellProps}
                data-key={task.id}
              />
            )
          })}
        </InnerCellContainer>
      )}
    </CellContainer>
  );
};

const CellContainer = styled.div<{groupPosition: string}>`
  width: 40px;
  height: 40px;
  background-color: rgb(170, 170, 170);
  margin: 1px;
  position: relative;
  border-radius: ${props => {
    if (props.groupPosition === 'start') {
      return `10px 0 0 10px;`
    }
    if (props.groupPosition === 'end') {
      return `0 10px 10px 0;`
    }
  }}
`

const InnerCellContainer = styled.div<{groupPosition: string}>`
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  right: 0;
  overflow: hidden;
  pointer-events: none;
  border-radius: ${props => {
    if (props.groupPosition === 'start') {
      return `10px 0 0 10px;`
    }
    if (props.groupPosition === 'end') {
      return `0 10px 10px 0;`
    }
  }}
`

const InnerCell = styled.div`
  height: 100%;
  position: absolute;
  pointer-events: none;
`

================
File: src\components\Cell\components\SelectedCellOverlay.tsx
================
import styled, {keyframes} from "styled-components";

export const SelectedCellOverlay = ({pickedColor, groupPosition}) => {
  return (
    <Overlay
      className="overlay"
      draggable="false"
      groupPosition={groupPosition}
      pickedColor={pickedColor}
    />
  );
};

const overlayAnimation = keyframes`
  0% {
    transform: scale(1);
  }
  50% {
    transform: scale(1.09);
  }
  100% {
    transform: scale(1);
  }
`

const Overlay = styled.div<{groupPosition: string, pickedColor}>`
  pointer-events: none;
  z-index: 100;
  right: 0%;
  left: 0%;
  position: absolute;
  top: 0%;
  bottom: 0%;
  background-color: ${props => props.pickedColor};
  animation: ${overlayAnimation} 0.2s ease-in-out;
  border-radius: ${props => {
    switch (props.groupPosition) {
      case 'start':
        return '10px 0 0 10px';
      case 'end':
        return '0 10px 10px 0';
      default:
        return '0';
    }
  }};
`

================
File: src\components\RenderDateRange.tsx
================
import { useContext, useRef, useEffect, useState } from "react";
import SingleDay from "./SingleDay";
import { SelectedCellsContext } from "../contexts/SelectCellsContext";
import styled from "styled-components";
import TaskList from "./TaskList";

export const RenderDateRange = () => {
  const { cellsData } = useContext(SelectedCellsContext);
  const [currentFocusedDay, setCurrentFocusedDay] = useState('')
  const cellsWrapperRef = useRef()
  const dayComponentRefArray = useRef([])

  useEffect(() => {
    if (!currentFocusedDay && cellsData) {
      setCurrentFocusedDay(Object.keys(cellsData)[0])
    }
    function updateScrollPosition(e) {
        console.log(e.target.scrollTop)
        const numbersArray = dayComponentRefArray.current.map((dayComponent) => dayComponent.getBoundingClientRect())
        const scrollPosition = e.target.scrollTop
        const focusedDay = dayComponentRefArray.current
          .map((dayComponent) => dayComponent)
          .find((dayElement) => dayElement.getBoundingClientRect().top < 20 && dayElement.getBoundingClientRect().top + dayElement.getBoundingClientRect().height > 20)
        if (focusedDay && focusedDay.dataset.date !== currentFocusedDay) {
          const focusedDate = focusedDay.dataset.date
          setCurrentFocusedDay(focusedDate)
        }
    }

    if (cellsWrapperRef && cellsWrapperRef.current) {
      cellsWrapperRef.current.addEventListener("scroll", updateScrollPosition, false);//this needs debouncing
    }
    return () => {
      if (cellsWrapperRef && cellsWrapperRef.current) {
        cellsWrapperRef.current.removeEventListener("scroll", updateScrollPosition, false);
      }
    };
  }, []);

  return (
    <CellAndTaskWrapper>
      <CellsWrapper className="cell-render-container" ref={cellsWrapperRef}>
        {Object.keys(cellsData).map((key, index) => {
          return (
            <div key={key} data-date={key} ref={(ref) => {dayComponentRefArray.current[index] = ref}}>
              <SingleDay
                dayToRender={key}
                singleDayData={cellsData[key]}
              />
            </div>
          )
        })}
      </CellsWrapper>
      <TaskListWrapper>
        <TaskList singleDayDataOnScroll={currentFocusedDay}/>
      </TaskListWrapper>
    </CellAndTaskWrapper>
  );
};

const CellAndTaskWrapper = styled.div`
  position: relative;
  display: flex;
  margin: 0px;
  height: 100%;
  overflow: hidden;
  flex: 1;
`

const CellsWrapper = styled.div`
  height: 100%;
  overflow: auto;
  flex: 3;
`;

const TaskListWrapper = styled.div`
  flex: 1;
`

================
File: src\components\SingleDay.tsx
================
import { useState, useEffect, useContext, memo } from "react";
import { SelectedCellsContext } from "../contexts/SelectCellsContext.tsx"; // Import the context
import { Cell } from "./Cell/Cell.tsx";
import { cellGroupTotalTime } from "../data/cellGroupTotalTime.tsx";
import { ToolbarContext } from "../contexts/ToolbarContext.tsx";
import styled from "styled-components";
import { readableDate, readableTime } from "../utils/utils.ts";

const SingleDay = memo(({ dayToRender, singleDayData }) => {
  const { selectedCells } = useContext(SelectedCellsContext);
  const { minuteinput } = useContext(ToolbarContext);

  const cellsInGroup = cellGroupTotalTime[minuteinput] / minuteinput;

  //ensures that startIndex is the lowest number and endIndex is highest
  const startIndex = selectedCells
    ? Math.min(selectedCells.StartCell, selectedCells.EndCell)
    : null;
  const endIndex = selectedCells
    ? Math.max(selectedCells.StartCell, selectedCells.EndCell)
    : null;

  return (
    <SingleDayWrapper key={dayToRender} className="innercontainer" draggable="false">
      <h2 draggable="false">{readableDate(dayToRender)}</h2>
      <CellContainer id="cell-container" className="cell-container" draggable="false">
        {[...Array(Math.ceil(singleDayData.length / cellsInGroup))].map(
          (_, groupIndex) => {
            const start = groupIndex * cellsInGroup;
            const end = start + cellsInGroup;
            const groupOfCells = singleDayData.slice(start, end);

            // Generate the time label for this group
            const totalMinutes = groupIndex * cellGroupTotalTime[minuteinput];

            return (
              <CellGroupContainer key={groupIndex} className="cell-group-container">
                <CellGroup className="cell-group">
                  {groupOfCells.map((cell, index) => {
                    const cellIndex = index + start;
                    const isSelected =
                      selectedCells &&
                      dayToRender === selectedCells.day &&
                      cellIndex >= startIndex &&
                      cellIndex <= endIndex;
                    const groupPosition = index === 0 ? 'start' : index === cellsInGroup -1 ? 'end' : 'middle'
                    return (
                      <Cell
                        cellIndex={cellIndex}
                        cell={cell}
                        dayToRender={dayToRender}
                        selected={isSelected}
                        groupPosition={groupPosition}
                      />
                    );
                  })}
                </CellGroup>
                <TimeLabel className="timeLabel">{readableTime(totalMinutes)}</TimeLabel>
              </CellGroupContainer>
            );
          }
        )}
      </CellContainer>
    </SingleDayWrapper>
  );
});

const SingleDayWrapper = styled.div`
  max-width: 1200px;
`

const CellContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
`

const CellGroupContainer = styled.div`
  margin: 1px;
`

const CellGroup = styled.div`
  display: flex;
  flex-wrap: nowrap;
  border: 3px;
  padding: 1px 2px;
  margin: 0 -2px;
  border-style: solid;
  border-color: #cf2e27;
  position: relative;
  border-radius: 12px;
`

const TimeLabel = styled.p`
  font-size: 0.9rem;
  font-weight: 700;
  color: #00000073;
  margin: 0;
  padding: 0;
  margin-left: 5px;
`

export default SingleDay;

================
File: src\components\TaskList.tsx
================
import { useContext } from "react"
import { SelectedCellsContext } from "../contexts/SelectCellsContext"
import { ToolbarContext } from "../contexts/ToolbarContext"
import { readableTime } from "../utils/utils"
import styled from "styled-components"

const TaskList = ({singleDayDataOnScroll}) => {
    const {mouseOverTasks, currentTimeData} = useContext(SelectedCellsContext)
    const {tasks} = useContext(ToolbarContext)
    console.log(currentTimeData)

    return (
        <div>
            <h2>Tasks - {singleDayDataOnScroll}</h2>
            <StyledUl className="tasks">
            {mouseOverTasks.tasks && mouseOverTasks.tasks.map((mouseOverTask) => {
                const startTime = mouseOverTasks.startTime + mouseOverTask.startTime
                const endTime = mouseOverTasks.startTime + mouseOverTask.endTime
                return (
                    <li>
                        <p>{tasks[mouseOverTask.taskID].title}</p>
                        <p>{`${readableTime(startTime)} - ${readableTime(endTime)}`}</p>
                    </li>
                )
            })}
            </StyledUl>
            <StyledUl>
                {singleDayDataOnScroll && currentTimeData[singleDayDataOnScroll] && currentTimeData[singleDayDataOnScroll].map((time) => {
                    return (
                        <li>
                            <p>{tasks[time.taskID].title}</p>
                            <p>{`${readableTime(time.startTime)} - ${readableTime(time.endTime)}`}</p>
                        </li>
                    )
                })}
            </StyledUl>
        </div>
    )
}

const StyledUl = styled.ul`
    list-style: none;
    padding: 0;
`

export default TaskList

================
File: src\components\Toolbar.tsx
================
import { useContext } from "react";
import { ToolbarContext } from "../contexts/ToolbarContext";
import styled from "styled-components";

export const Toolbar = () => {
  const {
    inputValue,
    setInputValue,
    minuteinput,
    setMinuteInput,
    startDate,
    setStartDate,
    endDate,
    setEndDate,
    pickedColor,
    setPickedColor,
    eraseTool,
    setEraseTool,
    tasks,
  } = useContext(ToolbarContext);

  /*===============
    EVENT HANDLERS
    ===============*/

  //When the input box changes
  const handleIntervalChange = (event) => {
    setInputValue(event.target.value);
  };

  const handleIntervalSubmit = (event) => {
    event.preventDefault();
    let roundedValue = inputValue;

    // round to the nearest number that divides 1440 evenly
    if (inputValue > 1440) {
      roundedValue = 1440;
    } else if (1440 % inputValue !== 0) {
      // find the closest divisors
      let lowerDivisor = inputValue;
      let upperDivisor = inputValue;

      // find lower divisor
      while (1440 % --lowerDivisor !== 0) {}

      // find upper divisor
      while (1440 % ++upperDivisor !== 0) {}

      // choose the closest divisor
      roundedValue =
        inputValue - lowerDivisor < upperDivisor - inputValue
          ? lowerDivisor
          : upperDivisor;
    }
    setMinuteInput(roundedValue);
    setInputValue(roundedValue);
  };

  const handleStartDateChange = (event) => {
    setStartDate(event.target.value);
  };

  const handleEndDateChange = (event) => {
    setEndDate(event.target.value);
  };

  const handleToggleEraseTool = () => {
    setEraseTool(!eraseTool);
  };

  return (
    <ToolbarWrapper>
      {/* <p>Time: {targetTime}</p> */}
      <input
        type="color"
        value={pickedColor}
        onChange={(e) => setPickedColor(e.target.value)}
      />
      <p>Time per cell: </p>
      <form onSubmit={handleIntervalSubmit}>
        <input
          type="number"
          value={inputValue}
          onChange={handleIntervalChange}
        />
        <button type="submit">Submit</button>
      </form>
      <form>
        <label>
          Start Date:
          <input
            type="date"
            value={startDate}
            onChange={handleStartDateChange}
          />
        </label>
        <br></br>
        <label>
          End Date:
          <input type="date" value={endDate} onChange={handleEndDateChange} />
        </label>
      </form>
      <div>
        <button onClick={handleToggleEraseTool}>
          {eraseTool ? "Disable Erase Tool" : "Enable Erase Tool"}
        </button>
      </div>
    </ToolbarWrapper>
  );
};

const ToolbarWrapper = styled.menu`
  position: relative;
  display: flex;
  flex-direction: row;
  justify-content: space-between;
  align-items: center;
  background-color: #f8f9fa;
  padding: 0 1em;
  z-index: 100;
  margin: 0;
  margin-top: auto;
`

================
File: src\contexts\SelectCellsContext.tsx
================
import { createContext, useState, useEffect, useContext } from "react";
import { ToolbarContext } from "./ToolbarContext";
import timesToCells from "../utils/timesToCells";
import timesheetData from "../test/timesheet.json";

interface selectedCellsType {
  day: null | string;
  StartCell: null | number;
  EndCell: null | number;
}

interface selectCellsContextType {
  selectedCells: selectedCellsType;
  cellsData: Object;
  mouseOverTasks: Array<any>
  setMouseOverTasks?: React.Dispatch<React.SetStateAction<Array<any>>>;
  currentTimeData: Object;
}

export const SelectedCellsContext = createContext<selectCellsContextType | null>(
  null
);

export const SelectedCellsProvider = ({ children }) => {
  const { minuteinput, startDate, endDate } = useContext(ToolbarContext);
  const [selectedCells, setSelectedCells] = useState({
    day: null,
    StartCell: null,
    EndCell: null,
  });
  const [dataToInput, setDataToInput] = useState(null);
  const [targetTime, setTargetTime] = useState(0);

  const [FullRawData, setFullRawData] = useState(() => {
    const savedData = localStorage.getItem("timesheetData");
    return savedData ? JSON.parse(savedData) : timesheetData;
  });
  const [currentTimeData, setCurrentTimeData] = useState({})
  const [mouseOverTasks, setMouseOverTasks] = useState([])
  const [cellsData, setCellsData] = useState({});

  useEffect(() => {
    const start = new Date(startDate);
    const end = new Date(endDate);
    const cellObjectData = {}
    const rawData = {}
    for (let day = start; day <= end; day.setDate(day.getDate() + 1)) {
      const dayString = day.toISOString().substring(0, 10)
      rawData[dayString] = FullRawData[dayString]
      cellObjectData[dayString] = timesToCells(FullRawData[dayString], minuteinput)
    }
    setCurrentTimeData(rawData)
    setCellsData(cellObjectData)
  }, [startDate, endDate, FullRawData, minuteinput])

  //trigger the functions when the mouse events are started
  useEffect(() => {
    const handleMouseDown = (e) => {
      const targetDay = e.target.getAttribute("data-day");
      const targetCellIndex = e.target.getAttribute("data-cell-index");
      if (targetDay && targetCellIndex) {
        e.preventDefault();
        setSelectedCells({
          day: targetDay,
          StartCell: targetCellIndex,
          EndCell: targetCellIndex,
        });
      } else {
        setSelectedCells({
          day: null,
          StartCell: null,
          EndCell: null,
        });
      }
    };

    const handleMouseMove = (e) => {
      if (e.buttons === 1 && e) {
        // Get the element currently under the mouse pointer
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const targetDay = target.getAttribute("data-day");
        const targetCellIndex = target.getAttribute("data-cell-index");
        const mouseRolloutCheck = [
          "timeLabel",
          "cell-container",
          "cell-group-container",
          "cell-group",
          "innercontainer",
        ];
        if (targetDay && targetCellIndex && targetDay === selectedCells.day) {
          setSelectedCells((prevState) => ({
            ...prevState,
            EndCell: targetCellIndex,
          }));
        } else if (
          !mouseRolloutCheck.some((className) =>
            target.classList.contains(className)
          )
        ) {
          setSelectedCells({
            day: null,
            StartCell: null,
            EndCell: null,
          });
        }
      } else {
        const target = document.elementFromPoint(e.clientX, e.clientY);
        const targetDay = target.getAttribute("data-day");
        const targetCellIndex = target.getAttribute("data-cell-index");
        if (targetDay && targetCellIndex) {
          setMouseOverTasks(cellsData[targetDay][targetCellIndex])
        }
      }
      if (/^cell-\d+$/.test(e.target.id)) {
        if (e.target.dataset.time !== targetTime) {
          // Log the data-time attribute
          setTargetTime(e.target.dataset.time);
        }
      } else {
        setTargetTime(null);
      }
    };

    const handleMouseUp = () => {
      if (selectedCells.day && selectedCells.StartCell && selectedCells.EndCell) {
        //reset the active cells
        const startIndex = selectedCells
          ? Math.min(selectedCells.StartCell, selectedCells.EndCell)
          : null;
        const endIndex =
          (selectedCells
            ? Math.max(selectedCells.StartCell, selectedCells.EndCell)
            : null) + 1;
        //add the inputed time to the active time array
        const newdataToInput = {
          [selectedCells.day]: [
            {
              startTime: startIndex * minuteinput,
              endTime: endIndex * minuteinput,
              Color: null,
            },
          ],
        };
        setDataToInput(newdataToInput);
      }
    };

    window.addEventListener("mousedown", handleMouseDown);
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
    return () => {
      window.removeEventListener("mousedown", handleMouseDown);
      window.removeEventListener("mousemove", handleMouseMove);
      window.removeEventListener("mouseup", handleMouseUp);
    };
  });

  return (
    <SelectedCellsContext.Provider value={{ selectedCells, cellsData, mouseOverTasks, currentTimeData }}>
      {children}
    </SelectedCellsContext.Provider>
  );
};

================
File: src\contexts\ToolbarContext.tsx
================
import { createContext, useEffect, useState } from "react";
import taskData from "../test/taskData.json";

interface toolbarContextType {
  inputValue: number;
  setInputValue: React.Dispatch<React.SetStateAction<number>>;
  minuteinput: number;
  setMinuteInput: React.Dispatch<React.SetStateAction<number>>;
  startDate: string;
  setStartDate: React.Dispatch<React.SetStateAction<string>>;
  endDate: string;
  setEndDate: React.Dispatch<React.SetStateAction<string>>;
  pickedColor: string;
  setPickedColor: React.Dispatch<React.SetStateAction<string>>;
  eraseTool: boolean;
  setEraseTool: React.Dispatch<React.SetStateAction<boolean>>;
  tasks: object;
  setTasks: React.Dispatch<React.SetStateAction<object>>;
}

export const ToolbarContext = createContext<toolbarContextType | null>(null);

export const ToolbarProvider = ({ children }) => {
  const [inputValue, setInputValue] = useState(15);
  const [minuteinput, setMinuteInput] = useState(15);
  const [startDate, setStartDate] = useState(
    new Date().toISOString().substring(0, 10)
  );
  const [endDate, setEndDate] = useState(
    new Date().toISOString().substring(0, 10)
  );
  const [pickedColor, setPickedColor] = useState("#000000");
  const [eraseTool, setEraseTool] = useState(false);

  const [tasks, setTasks] = useState(() => {
    const savedData = localStorage.getItem("taskData");
    return savedData ? JSON.parse(savedData) : taskData;
  });

  return (
    <ToolbarContext.Provider
      value={{
        inputValue,
        setInputValue,
        minuteinput,
        setMinuteInput,
        startDate,
        setStartDate,
        endDate,
        setEndDate,
        pickedColor,
        setPickedColor,
        eraseTool,
        setEraseTool,
        tasks,
        setTasks
      }}
    >
      {children}
    </ToolbarContext.Provider>
  );
};

================
File: src\data\cellGroupTotalTime.tsx
================
//number of minutes per cell:number of minutes per group
export const cellGroupTotalTime = {
    1: 5,
    2: 10,
    3: 15,
    4: 20,
    5: 30,
    6: 30,
    8: 80,
    9: 45,
    10: 60,
    12: 60,
    15: 60,
    16: 80,
    18: 90,
    20: 60,
    24: 120,
    30: 60,
    32: 160,
    36: 180,
    40: 360,
    45: 360,
    48: 240,
    60: 360,
    72: 360,
    80: 240,
    90: 360,
    96: 480,
    120: 480,
    144: 720,
    160: 320,
    180: 720,
    240: 720,
    288: 1440,
    360: 720,
    480: 1440,
    720: 1440,
    1440: 1440,
}

================
File: src\main.tsx
================
import React from 'react'
import ReactDOM from 'react-dom/client'
import App from './App.tsx'
import './index.css'

ReactDOM.createRoot(document.getElementById('root')!).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>,
)

================
File: src\test\taskData.json
================
{
    "1": {
        "color": "#fff000",
        "title": "Making Cookies",
        "description": "baking cookies for gram gram",
        "category": "cooking"
    },
    "2": {
        "color": "#ff0000",
        "title": "Eating Cookies",
        "description": "eating gram gram's cookies",
        "category": "eating"
    },
    "3": {
        "color": "#ff63db",
        "title": "Washing Dishes",
        "description": "washing the dishes after baking and eating cookies",
        "category": "chores"
    },
    "4": {
        "color": "#00ff00",
        "title": "Grocery Shopping",
        "description": "buying ingredients for making more cookies",
        "category": "errands"
    },
    "5": {
        "color": "#0000ff",
        "title": "Walking the Dog",
        "description": "taking the dog for a walk in the park",
        "category": "exercise"
    },
    "6": {
        "color": "#ff8000",
        "title": "Reading a Book",
        "description": "finishing the last chapter of the current book",
        "category": "leisure"
    },
    "7": {
        "color": "#8a2be2",
        "title": "Studying for Exam",
        "description": "reviewing notes for the upcoming exam",
        "category": "education"
    },
    "8": {
        "color": "#a52a2a",
        "title": "Cleaning the House",
        "description": "tidying up the living room and bedrooms",
        "category": "chores"
    },
    "9": {
        "color": "#ff69b4",
        "title": "Gardening",
        "description": "planting new flowers in the garden",
        "category": "outdoors"
    },
    "10": {
        "color": "#00ced1",
        "title": "Calling a Friend",
        "description": "catching up with a friend over the phone",
        "category": "social"
    },
    "11": {
        "color": "#ff4500",
        "title": "Writing a Letter",
        "description": "writing a letter to a pen pal",
        "category": "communication"
    },
    "12": {
        "color": "#2e8b57",
        "title": "Yoga Session",
        "description": "attending a yoga class at the local studio",
        "category": "exercise"
    },
    "13": {
        "color": "#4682b4",
        "title": "Watching a Movie",
        "description": "watching the latest movie release",
        "category": "entertainment"
    }
}

================
File: src\test\timesheet.json
================
{
  "2024-07-18": [
    { "startTime": 0, "endTime": 5, "taskID": 2 },
    { "startTime": 348, "endTime": 600, "taskID": 6 },
    { "startTime": 960, "endTime": 1200, "taskID": 4 },
    { "startTime": 1200, "endTime": 1399, "taskID": 13 }
  ],
  "2024-07-19": [
    { "startTime": 101, "endTime": 205, "taskID": 3 },
    { "startTime": 207, "endTime": 210, "taskID": 10 },
    { "startTime": 420, "endTime": 600, "taskID": 8 }
  ],
  "2024-07-20": [
    { "startTime": 600, "endTime": 900, "taskID": 1 },
    { "startTime": 1200, "endTime": 1440, "taskID": 5 },
    { "startTime": 900, "endTime": 950, "taskID": 7 }
  ]
}

================
File: src\utils\timesToCells.tsx
================
interface TaskTime {
  startTime: number;
  endTime: number;
  taskID: string;
}

class cellObject {
  tasks: Array<TaskTime>
  startTime:number
  numOfMinutes:number
  constructor(startTime, numOfMinutes) {
    this.tasks = []
    this.startTime = startTime
    this.numOfMinutes = numOfMinutes
  }
  newTaskTime = (task: TaskTime) => {
    this.tasks.push(task)
  }
  getCellProps = (task, backgroundColor) => {
    return {
      id: `${task.startTime}`,
      taskID: task.taskID,
      style: {
        left: `${(task.startTime / this.numOfMinutes) * 100}%`,
        right: `${(1 - (task.endTime / this.numOfMinutes)) * 100}%`,//this may need changing
        backgroundColor: backgroundColor
      }
    }
  }
}

const timesToCells = (timesArray, timePerCell, numOfMinutes = 1440) => {
  const numberOfCells = numOfMinutes / timePerCell;

  const cellsArray = Array.from({ length: numberOfCells }, (_, index) => new cellObject(index * timePerCell, timePerCell));
  if (timesArray) {
    timesArray.forEach((event) => {
      const startPositionInCell = event.startTime / timePerCell;
      const endPositionInCell = event.endTime / timePerCell;
      const startCell = Math.floor(startPositionInCell);
      const endCell = Math.ceil(endPositionInCell) - 1;
      for (let i = startCell; i <= endCell; i++) {
        cellsArray[i].newTaskTime({
          startTime: Math.max(0, (event.startTime - cellsArray[i].startTime)),
          endTime: Math.min(timePerCell, (event.endTime - cellsArray[i].startTime)),
          taskID: event.taskID
        })
      }
    });
  }
  return cellsArray;
};
export default timesToCells;

================
File: src\utils\updateData.ts
================
//goes through each day in dataToInput, adds it to newData, then replaces FullData with newData
export const updateData = (
    dataToInput,
    FullData,
    taskTitle,
    pickedColor,
    eraseTool
  ) => {
    const newData = [...FullData];

    for (const day in dataToInput) {
      const dayIndex = newData.findIndex(
        (dayData) => Object.keys(dayData)[0] === day
      );

      if (dayIndex !== -1) {
        let dayData = newData[dayIndex][day];

        dataToInput[day].forEach((newBlock) => {
          // Update color and title only if eraseTool is not active
          if (!eraseTool) {
            newBlock.Color = pickedColor;
            newBlock.Title = taskTitle;
          }

          dayData = dayData.reduce(
            (updatedDayData, existingBlock) => {
              if (
                newBlock.startTime > existingBlock.endTime ||
                newBlock.endTime < existingBlock.startTime
              ) {
                updatedDayData.push(existingBlock); // No overlap
              } else {
                // Overlap handling
                if (newBlock.startTime > existingBlock.startTime) {
                  updatedDayData.push({
                    ...existingBlock,
                    endTime: newBlock.startTime,
                  });
                }
                if (newBlock.endTime < existingBlock.endTime) {
                  updatedDayData.push({
                    ...existingBlock,
                    startTime: newBlock.endTime,
                  });
                }
              }
              return updatedDayData;
            },
            eraseTool ? [] : [newBlock]
          ); // Start with new block if not erasing

          // Sort the day data based on startTime
          dayData.sort((a, b) => a.startTime - b.startTime);
        });

        newData[dayIndex][day] = dayData;
      } else {
        if (!eraseTool) {
          const newDay = {
            [day]: dataToInput[day].map((timeBlock) => ({
              ...timeBlock,
              Color: pickedColor,
              Title: taskTitle,
            })),
          };
          newData.push(newDay);
        }
        // If eraseTool is active, do not add a new day
      }
    }

    return newData;
  };

================
File: src\utils\utils.ts
================
export const readableDate = (dateString: string) => {
    const date = new Date(dateString);

    // Array of weekdays
    const weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];

    // Array of month names
    const months = [
        "January", "February", "March", "April", "May", "June",
        "July", "August", "September", "October", "November", "December"
    ];

    const weekday = weekdays[date.getUTCDay()];
    const day = date.getUTCDate();
    const month = months[date.getUTCMonth()];
    const year = date.getUTCFullYear();

    // Adding suffix to day
    let daySuffix;
    if (day % 10 === 1 && day !== 11) {
        daySuffix = 'st';
    } else if (day % 10 === 2 && day !== 12) {
        daySuffix = 'nd';
    } else if (day % 10 === 3 && day !== 13) {
        daySuffix = 'rd';
    } else {
        daySuffix = 'th';
    }

    return `${weekday} ${day}${daySuffix} ${month} ${year}`;
}

export const readableTime = (numOfMinutes) => {
    const hours = String(Math.floor(numOfMinutes / 60)).padStart(2, "0");
    const minutes = String(numOfMinutes % 60).padStart(2, "0");
    return `${hours}:${minutes}`;
}

================
File: src\vite-env.d.ts
================
/// <reference types="vite/client" />

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "module": "ESNext",
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx",

    /* Linting */
    //"strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true
  },
  "include": ["src", "src/*"],
  "references": [{ "path": "./tsconfig.node.json" }]
}

================
File: tsconfig.node.json
================
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}

================
File: vite.config.ts
================
import { defineConfig } from 'vite'
import react from '@vitejs/plugin-react'

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react()],
})
